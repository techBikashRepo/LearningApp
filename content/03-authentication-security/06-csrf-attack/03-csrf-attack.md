# CSRF Attack — Part 3 of 3

### Sections: 9 (Interview Prep), 10 (Common Developer Mistakes), 11 (Quick Revision), 12 (Security Thinking Exercise)

**Series:** Authentication & Security → Topic 06

---

## SECTION 9 — Interview Prep: Layered Answers

### Beginner Level

**Q: What is a CSRF attack?**

```
CSRF (Cross-Site Request Forgery) is an attack where an attacker tricks a victim's browser
into making an unwanted request to a website the victim is authenticated on.

Simple example:
  You're logged into your bank. Your browser has a valid session cookie for bank.com.
  You visit evil.com. It has a hidden form that auto-submits to bank.com/transfer.
  Your browser sends the request — it automatically includes your bank.com session cookie.
  The bank sees: valid session → executes the transfer.
  You didn't authorize it. The attacker never needed your password.

Core exploit: browsers automatically attach cookies to every matching request,
regardless of which website initiated that request.
```

**Q: What is a CSRF token and how does it protect against CSRF?**

```
A CSRF token is a secret, unpredictable value generated by the server and tied to a user's session.
It's embedded in every form/included in every state-changing API request.
The server validates it matches the stored value before processing the request.

WHY IT WORKS:
  The attacker's evil.com can trigger a cross-site request (CSRF attempt).
  The request includes the victim's session cookie (browser sends automatically).
  BUT: evil.com cannot read the CSRF token (Same-Origin Policy prevents JS from
       reading cookies or responses from other origins).
  So: attacker cannot include the correct CSRF token in the forged request.
  Server sees: mismatched or missing CSRF token → rejects with 403.

MECHANISM:
  Server generates: token = crypto.randomBytes(32).toString('hex')
  Server stores: in session (or signed cookie)
  Server sends to client: via cookie (not HttpOnly) or embedded in HTML
  Client includes: in X-CSRF-Token header or _csrf form field
  Server validates: header/field token === session token (constant-time compare)
```

---

### Intermediate Level

**Q: What's the difference between SameSite=Lax and SameSite=Strict?**

```
SameSite=Lax:
  Cookie IS sent when user clicks a link (top-level GET navigation) from external site.
  Cookie is NOT sent on cross-site POST forms, img loads, iframe loads.

  Example: User clicks a Google result linking to your site → session cookie sent.
           Otherwise user appears logged out on first click-through. Good UX.

  Does NOT protect against: GET-based CSRF endpoints, subdomain CSRF.

SameSite=Strict:
  Cookie is NEVER sent on any cross-site request, including top-level GET navigations.

  Example: User clicks a Google result → session cookie NOT sent → user appears logged out.
           User must navigate to site manually or reload for cookie to be included.

  Maximum CSRF protection. Worst for apps where users arrive via external links.
  Best for: banking, admin panels, apps that should only be used via bookmarks/direct URL.

RECOMMENDATION: SameSite=Lax + CSRF Token on all mutations = standard best practice.
                Use SameSite=Strict for high-security operations (banking, admin).
```

**Q: Why is SameSite alone not sufficient CSRF protection?**

```
SameSite protects cookies. It doesn't validate the receiving server's logic.

SCENARIOS WHERE SAMESITE FAILS:

1. Same-site subdomain attack:
   You host user-controlled content on upload.yoursite.com.
   upload.yoursite.com IS same-site as app.yoursite.com.
   An XSS on upload.yoursite.com can forge CSRF requests to app.yoursite.com.
   SameSite=Lax ALLOWS this (same-site = different subdomain of same registrable domain).

2. GET endpoints with state changes:
   SameSite=Lax still sends cookie on top-level GET navigations.
   If you have GET /delete-account: SameSite=Lax won't block it.

3. Older browsers:
   iOS Safari < 13, older Android browsers: some don't support SameSite.
   CSRF tokens work regardless of browser support.

4. Future cookie policy changes:
   Browser vendors can change default SameSite behavior. CSRF tokens are app-controlled.

CONCLUSION: SameSite = first line of defense. CSRF token = defense in depth.
            Both together = standard recommendation.
```

---

### Senior/Advanced Level

**Q: How would you design CSRF protection for a stateless microservices architecture?**

```
CHALLENGE: Synchronizer token pattern requires server-side session storage.
           In stateless JWT-based microservices, there's no shared session store.
           You can't store CSRF tokens in a central Redis if services are fully decoupled.

OPTION 1: Double-Submit Cookie Pattern (stateless, no server storage)
  Issue two cookies on auth:
    a. JWT access token in HttpOnly cookie (server validates, attacker can't read)
    b. CSRF token in JS-readable cookie (attacker can't read via SOP)

  Frontend: reads CSRF cookie → includes in X-CSRF-Token header.
  Backend: validates header token == cookie token.

  Why it works: Attacker can forge a cross-site request with the session cookie.
  Attacker CANNOT set the X-CSRF-Token header to match the CSRF cookie
  (SOP prevents attacker's JS from reading your domain's cookies).

  Limitation: If an XSS exists on your site, attacker CAN read both cookies.
  Mitigation: Use Signed Double-Submit (HMAC(sessionId, pepper) as CSRF token).

OPTION 2: Custom Request Header (AJAX-only)
  For pure JSON APIs called exclusively via JavaScript fetch/Axios:
  Require a custom header: X-Requested-With: XMLHttpRequest
  OR: Content-Type: application/json with strict Content-Type validation

  Cross-origin form POSTs CANNOT set custom headers (HTML form limitation).
  AJAX cross-origin requests with custom headers trigger CORS preflight.
  If CORS is correctly configured (not wildcard): preflight fails for attacker.

  Works ONLY if:
    1. You never accept HTML form submissions (pure API)
    2. CORS is strict (no wildcard)

OPTION 3: Signed CSRF Token (Best for microservices)
  Auth service issues: CSRF_TOKEN = HMAC-SHA256(userId + timestamp, CSRF_SECRET)
  Client stores in JS-readable cookie or localStorage.
  Each microservice validates HMAC without needing to call Auth service.

  Secret shared via Secrets Manager (all services get the CSRF_SECRET).
  No shared Redis needed. Stateless validation.
```

---

## SECTION 10 — 10 Common Developer Mistakes

### Mistake 1: Using GET Endpoints for State Changes

```javascript
// WRONG: GET triggers state change → vulnerable to img tag CSRF
app.get("/api/friend-add/:userId", authenticate, async (req, res) => {
  await addFriend(req.user.id, req.params.userId);
  res.json({ success: true });
});
// Attacker: <img src="https://yourapp.com/api/friend-add/attacker_id">

// RIGHT: State changes always require POST/PUT/DELETE
app.post(
  "/api/friend-add/:userId",
  authenticate,
  validateCsrf,
  async (req, res) => {
    await addFriend(req.user.id, req.params.userId);
    res.json({ success: true });
  },
);
```

### Mistake 2: Wildcard CORS with Credentials

```javascript
// WRONG: Wildcard origin + credentials = any site can send authenticated requests
app.use(cors({ origin: "*", credentials: true }));
// Browser: blocks this combination. But if you work around it:
// → All cross-site requests carry your users' cookies. CSRF without forged forms.

// RIGHT: Explicit allowed origins
app.use(
  cors({
    origin: ["https://app.yoursite.com"],
    credentials: true,
  }),
);
```

### Mistake 3: CSRF Middleware Only on Some Routes

```javascript
// WRONG: Manual route-level CSRF check — easy to forget
app.post("/api/transfer", csrfCheck, transferHandler); // Protected
app.post("/api/update-email", updateEmailHandler); // FORGOTTEN! Unprotected!
app.delete("/api/account", csrfCheck, deleteHandler); // Protected

// RIGHT: Apply CSRF middleware globally to all state-changing methods
app.use(csrfValidationMiddleware); // Applies to ALL routes. No route gets missed.
// Add exceptions EXPLICITLY (with comments) only for things like webhooks or public APIs.
```

### Mistake 4: HttpOnly on the CSRF Cookie

```javascript
// WRONG: CSRF token cookie is HttpOnly — JavaScript can't read it!
res.cookie("XSRF-TOKEN", csrfToken, { httpOnly: true, secure: true });
// → React app can't include the token in headers.
// → Every state-changing request gets 403 CSRF failure.
// → Developer disables CSRF protection to "fix" it. ← Catastrophic.

// RIGHT: CSRF cookie is explicitly NOT HttpOnly (JS needs to read it)
res.cookie("XSRF-TOKEN", csrfToken, {
  httpOnly: false, // ← intentional: frontend JS reads this and includes in header
  secure: true, // ← still required: HTTPS only
  sameSite: "Strict",
});
// Session cookie: HttpOnly=true (secret, only used by browser)
// CSRF cookie: HttpOnly=false (not secret — attacker knowing the value doesn't help them
//              since they still can't set the matching header from attacker.com)
```

### Mistake 5: Not Regenerating CSRF Token After Login

```javascript
// WRONG: CSRF token from pre-auth session carried into post-auth session
// If attacker can plant a known CSRF token before authentication (session fixation pattern):
// → attacker knows the CSRF token → can forge requests after victim logs in

// RIGHT: Regenerate on privilege changes (same as session ID regeneration)
async function loginHandler(req, res) {
  const user = await authenticate(req.body.email, req.body.password);

  // Regenerate session ID (prevents session fixation)
  await new Promise((resolve, reject) =>
    req.session.regenerate((err) => (err ? reject(err) : resolve())),
  );

  // New session → new CSRF token
  req.session.userId = user.id;
  req.session.csrfToken = crypto.randomBytes(32).toString("hex");
  await req.session.save();

  res.cookie("XSRF-TOKEN", req.session.csrfToken, {
    httpOnly: false,
    secure: true,
  });
}
```

### Mistake 6: CSRF Token in URL Parameter

```javascript
// WRONG: CSRF token in URL — logged in access logs, Referer headers, browser history
app.post('/transfer?_csrf=abc123&amount=5000', ...)
// Token now in:
//  - Server access logs (Apache, nginx, CloudWatch)
//  - CloudFront access logs
//  - Browser history
//  - Referer header if user navigates to another page
// Attacker with log access can extract CSRF tokens.

// RIGHT: CSRF token in header or hidden form field only
// Header: X-CSRF-Token: abc123
// Form:   <input type="hidden" name="_csrf" value="abc123">
```

### Mistake 7: Not Validating the Content-Type Header

```javascript
// WRONG: Server accepts any content-type for JSON endpoint
app.post("/api/action", csrfMiddleware, async (req, res) => {
  const { action } = req.body;
  // ...
});
// If Content-Type: text/plain is accepted, simple request (no CORS preflight)
// → browser sends it cross-origin with cookies (CSRF vector)

// RIGHT: Strict Content-Type validation
app.post("/api/action", csrfMiddleware, async (req, res) => {
  if (!req.is("application/json")) {
    return res.status(400).json({ error: "CONTENT_TYPE_REQUIRED" });
  }
  const { action } = req.body;
  // ...
});
```

### Mistake 8: Skipping CSRF for "Internal" Endpoints

```javascript
// WRONG: "It's internal, no CSRF needed"
app.post(
  "/internal/admin/promote-user",
  internalNetworkCheck,
  promoteUserHandler,
);
// If /internal is accessible from the victim's browser (even via intranet): CSRF applies.
// CSRF doesn't require internet access. LAN attacks use same technique.

// RIGHT: CSRF protection applies everywhere a browser-authenticated user can reach.
app.post(
  "/internal/admin/promote-user",
  internalNetworkCheck,
  csrfValidationMiddleware, // Still required
  requireAdminRole,
  promoteUserHandler,
);
```

### Mistake 9: Non-Constant-Time CSRF Token Comparison

```javascript
// WRONG: String comparison leaks timing info (vulnerable to timing attack on CSRF tokens)
if (submittedToken !== sessionToken) {
  return res.status(403).json({ error: "INVALID_CSRF" });
}

// RIGHT: crypto.timingSafeEqual
const a = Buffer.from(submittedToken || "", "utf8");
const b = Buffer.from(sessionToken || "", "utf8");
const valid = a.length === b.length && crypto.timingSafeEqual(a, b);
if (!valid) return res.status(403).json({ error: "INVALID_CSRF" });
```

### Mistake 10: Long-Lived or Non-Rotated CSRF Tokens

```javascript
// WRONG: Same CSRF token for entire account lifetime
// If CSRF token is leaked (via logs, URL, XSS), attacker has permanent forge capability.

// RIGHT: Tie CSRF token TTL to session TTL, rotate on session regeneration
// Session expires: CSRF token must expire with it (store in session)
// New login: new session → new CSRF token
// Password reset: new session → new CSRF token
// Never store in a separate, longer-lived store than the session itself.
```

---

## SECTION 11 — Quick Revision

### 10 Key Takeaways

1. **CSRF borrows the victim's browser**: The attacker never needs credentials — just needs the victim to visit a malicious page while authenticated.

2. **Root cause**: Browsers automatically attach cookies to all requests to a domain, regardless of where the request was initiated.

3. **CSRF token = unpredictable, per-session secret**: Server generates it. SOP prevents attacker from reading it. Server validates it on all mutations.

4. **SameSite=Lax blocks most classic CSRF**: But fails on GET-based mutations, same-site subdomains, and legacy browsers.

5. **Both SameSite + CSRF token**: Layered defense. SameSite as first filter, CSRF token as cryptographic guarantee.

6. **CSRF cookie must NOT be HttpOnly**: Frontend JavaScript must read it to include in the `X-CSRF-Token` header.

7. **Session cookie MUST be HttpOnly**: Attacker's JS on the same origin shouldn't steal it. CSRF cookie not HttpOnly ≠ unsafe (the value is public to same-origin JS; attacker.com can't read it).

8. **GET endpoints must be read-only**: Any state change (add/update/delete) belongs on POST/PUT/DELETE, never GET.

9. **CORS wildcard + credentials = CSRF enabled**: `Access-Control-Allow-Origin: *` with `credentials: true` must never be used.

10. **Constant-time comparison for CSRF tokens**: Even CSRF token matching should use `crypto.timingSafeEqual` to prevent timing attacks revealing token hints.

---

### 30-Second Interview Answer

**"How do you protect against CSRF attacks?"**

```
"CSRF exploits the fact that browsers automatically send cookies on requests initiated
from ANY site — including attacker-controlled pages.

My defense uses two layers:
First: SameSite=Lax on session cookies, which tells the browser not to send cookies
       on cross-site POST requests or sub-resource loads.

Second: A CSRF token — a random 256-bit value generated per-session, stored server-side,
        exposed as a JS-readable cookie, and required as an X-CSRF-Token header on all
        state-changing requests. Attackers can never forge this because Same-Origin Policy
        blocks their JavaScript from reading my domain's cookies.

Additionally: all state changes are POST/PUT/DELETE — never GET.
CORS is configured with an explicit allowlist — never wildcard with credentials."
```

---

### Mnemonics

```
CSRF (What It Is):
  C — Cross-site (initiated from attacker.com)
  S — Sends (victim's browser sends cookies automatically)
  R — Requests (forged request to your server)
  F — Forged (server can't distinguish from legitimate request)

SAME (SameSite values):
  S — Strict (never sent cross-site — breaks external link UX)
  A — All blocked except top-level (Lax — good default)
  M — Multiple headers needed beyond SameSite (CSRF token too)
  E — Explicit None (opt-in — requires Secure flag, use only for embedded widgets)

TOKEN (CSRF Token rules):
  T — Tied to session (same TTL, rotated on login)
  O — Opaque random bytes (crypto.randomBytes(32))
  K — Keep in header or hidden field (never in URL)
  E — Exposed as JS-readable cookie (httpOnly: false on CSRF cookie)
  N — Not HttpOnly on CSRF cookie (JS must read it to include in header)
```

---

## SECTION 12 — Security Thinking Exercise

### Scenario: QuickPay Financial App

Review of the authentication and CSRF protection in a fintech app:

```javascript
// auth.js — Session and CSRF configuration
app.use(
  session({
    secret: "mysecret",
    resave: true,
    saveUninitialized: true,
    cookie: {
      httpOnly: true,
      secure: false, // "Some users are on HTTP" — developer comment
      sameSite: "None",
    },
  }),
);

// csrf.js
app.use((req, res, next) => {
  if (!req.session.csrf) {
    req.session.csrf = Math.random().toString(); // "Random enough" — developer comment
  }
  res.cookie("csrf-token", req.session.csrf, { httpOnly: true }); // Protected!
  next();
});

// transfer.js
app.get("/api/transfer", authenticate, (req, res) => {
  // GET for simplicity
  const { to, amount } = req.query;
  processTransfer(req.user.id, to, amount);
  res.json({ success: true });
});

app.post("/api/update-email", authenticate, (req, res) => {
  // "CSRF not needed, it's JSON"
  const { newEmail } = req.body;
  updateUserEmail(req.user.id, newEmail);
  res.json({ success: true });
});
```

---

### Your Task

**Identify all CSRF and related vulnerabilities. Rewrite securely.**

---

### Analysis: Problems Found

```
PROBLEM 1: SameSite=None on session cookie (CRITICAL)
  Explicitly allows cross-site requests to carry the session cookie.
  SameSite=None: opt-in to old insecure behavior.
  Combined with secure:false: cookie can be sent over HTTP (interception risk).
  Impact: full CSRF vulnerability via form-based or img-based attacks.

PROBLEM 2: secure: false on session cookie (HIGH)
  Cookie sent over HTTP. Sessions interceptable on non-HTTPS connections.
  Modern apps: ALL traffic should be HTTPS. HTTP should redirect to HTTPS.

PROBLEM 3: Math.random() for CSRF token (HIGH)
  Math.random() is NOT cryptographically secure.
  Output is predictable if attacker observes enough values (Mersenne Twister).
  Impact: CSRF token can be predicted → CSRF token protection defeated.
  Fix: crypto.randomBytes(32).toString('hex')

PROBLEM 4: CSRF cookie is HttpOnly (HIGH)
  httpOnly: true on the CSRF token cookie.
  Frontend JavaScript cannot read it → cannot include in X-CSRF-Token header.
  This means: CSRF token is never being validated (it CAN'T be, unless it's in forms).
  Or: developers disabled CSRF validation because it never worked. Security theater.

PROBLEM 5: GET endpoint for money transfer (CRITICAL)
  GET /api/transfer with query params.
  <img src="/api/transfer?to=attacker&amount=5000"> executes this.
  Even if SameSite is fixed: GET-based CSRF still bypasses SameSite=Lax
  (Lax allows cookies on top-level GET navigations — img is a subrequest, so blocked,
  but direct link navigation is allowed).
  Regardless: money transfer should NEVER be a GET endpoint.

PROBLEM 6: "CSRF not needed for JSON" (HIGH)
  JSON API via POST: custom Content-Type (application/json) triggers CORS preflight.
  BUT: if CORS is misconfigured (wildcard or loose), preflight passes.
  AND: if Content-Type is not strictly validated, text/plain can be used (no preflight).
  Impact: update-email reachable via CSRF.
```

### Secure Rewrite

```javascript
import crypto from "crypto";
import session from "express-session";
import RedisStore from "connect-redis";

// auth.js — SECURE session config
app.use(
  session({
    store: new RedisStore({ client: redisClient }),
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    name: "__Host-sid",
    cookie: {
      httpOnly: true,
      secure: true, // HTTPS required
      sameSite: "Lax", // Blocks most cross-site requests
      maxAge: 8 * 60 * 60 * 1000,
    },
  }),
);

// csrf.js — SECURE CSRF middleware
const CSRF_COOKIE = "XSRF-TOKEN";

app.use((req, res, next) => {
  if (!req.session?.id) return next();

  if (!req.session.csrfToken) {
    req.session.csrfToken = crypto.randomBytes(32).toString("hex"); // Cryptographically secure
  }

  res.cookie(CSRF_COOKIE, req.session.csrfToken, {
    httpOnly: false, // JS-readable: frontend includes in header
    secure: true,
    sameSite: "Strict",
    path: "/",
  });

  next();
});

// CSRF validation middleware — applied globally
app.use((req, res, next) => {
  if (["GET", "HEAD", "OPTIONS"].includes(req.method)) return next();

  const submitted = req.headers["x-csrf-token"];
  const stored = req.session?.csrfToken;

  if (!submitted || !stored)
    return res.status(403).json({ error: "CSRF_MISSING" });

  const a = Buffer.from(submitted, "utf8");
  const b = Buffer.from(stored, "utf8");

  if (a.length !== b.length || !crypto.timingSafeEqual(a, b)) {
    return res.status(403).json({ error: "CSRF_INVALID" });
  }

  next();
});

// transfer.js — SECURE: POST, not GET
app.post(
  "/api/transfer",
  authenticate,
  validateContentType("application/json"),
  (req, res) => {
    const { to, amount } = req.body; // Body, not query params
    processTransfer(req.user.id, to, amount);
    res.json({ success: true });
  },
);

// update-email.js — SECURE: CSRF middleware already applied globally
app.post(
  "/api/update-email",
  authenticate,
  validateContentType("application/json"),
  (req, res) => {
    const { newEmail } = req.body;
    updateUserEmail(req.user.id, newEmail);
    res.json({ success: true });
  },
);

// CHANGES:
// 1. SameSite: None → Lax  (blocks cross-site POST/subrequests)
// 2. secure: false → true   (HTTPS only)
// 3. Math.random() → crypto.randomBytes(32)  (unpredictable tokens)
// 4. CSRF cookie: httpOnly:true → false  (JS must read it)
// 5. GET /transfer → POST /transfer  (no money transfer via GET)
// 6. CSRF middleware applied globally to all mutations
// 7. Content-Type validation on JSON endpoints
```
